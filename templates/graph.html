<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{ .TabTitle }}</title>
    <style>
        /* Inject Main Site CSS */
        {{ .LayoutCSS }}
        {{ .ThemeCSS }}

        /* Overrides for Graph Page */
        body { 
            margin: 0 !important; 
            padding: 0 !important; /* Ensure no inherited padding shifts the canvas */
            overflow: hidden; 
            background-color: #2e3440; 
            color: #eceff4;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif;
            user-select: none;
        }
        
        canvas { 
            display: block; 
            width: 100vw; 
            height: 100vh;
            cursor: grab;
            touch-action: none;
        }
        canvas:active { cursor: grabbing; }

        #controls { 
            position: absolute; 
            top: 20px; 
            left: 20px; 
            z-index: 10; 
            pointer-events: none; 
        }
        
        .control-panel {
            background: rgba(46, 52, 64, 0.9);
            backdrop-filter: blur(4px);
            padding: 1.5rem;
            border-radius: 8px;
            border: 1px solid #4c566a;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            max-width: 300px;
            pointer-events: auto;
        }

        .control-panel h1 { 
            margin: 0 0 10px 0; 
            font-size: 1.5rem; 
            color: #88c0d0; 
        }
        
        .control-panel p { 
            margin: 5px 0; 
            font-size: 0.9rem; 
            color: #d8dee9; 
            line-height: 1.4;
        }

        .btn-home {
            display: inline-block;
            margin-top: 15px;
            padding: 8px 12px;
            background: #4c566a;
            color: #eceff4;
            text-decoration: none;
            border-radius: 4px;
            font-size: 0.85rem;
            transition: background 0.2s, transform 0.1s;
        }
        .btn-home:hover { background: #5e81ac; transform: translateY(-1px); }

        .label { 
            position: absolute; 
            background: rgba(46, 52, 64, 0.95); 
            color: #eceff4;
            padding: 6px 10px; 
            border-radius: 4px; 
            font-size: 12px; 
            pointer-events: none; 
            border: 1px solid #88c0d0;
            box-shadow: 0 4px 6px rgba(0,0,0,0.2);
            white-space: nowrap;
            z-index: 100;
            display: none;
            transform: translate(-50%, -150%);
        }
    </style>
</head>
<body>

<div id="controls">
    <div class="control-panel">
        <h1>Graph View</h1>
        <p>Interactive knowledge graph.</p>
        <p style="font-size: 0.8rem; opacity: 0.8;">• Scroll to Zoom<br>• Drag canvas to Pan<br>• Drag nodes to Move<br>• Click to Visit</p>
        <a href="{{ .BaseURL }}/" class="btn-home">← Back to Home</a>
    </div>
</div>

<div id="node-label" class="label"></div>
<canvas id="graphCanvas"></canvas>

<script>
    const canvas = document.getElementById('graphCanvas');
    const ctx = canvas.getContext('2d');
    const label = document.getElementById('node-label');

    let width, height;
    let nodes = [];
    let links = [];
    
    // Camera State
    let transform = { x: 0, y: 0, k: 0.8 }; 
    
    // Interaction State
    let draggedNode = null;
    let hoveredNode = null;
    let isPanning = false;
    let startPanX, startPanY;
    let dragStartTime = 0;
    let dragStartPos = {x:0, y:0};

    // Simulation State
    let alpha = 1.0; 

    const CONFIG = {
        repulsion: 2500,
        stiffness: 0.04,
        friction: 0.85,
        nodeRadius: 6,
        linkDistance: 100,
        colors: {
            post: '#88c0d0',      // Nord8
            tag: '#bf616a',       // Nord11
            link: '#4c566a',      // Nord3
            highlight: '#ebcb8b', // Nord13
            text: '#eceff4'       // Nord6
        }
    };

    async function loadGraph() {
        try {
            const response = await fetch('{{ .BaseURL }}/graph.json');
            const data = await response.json();
            init(data);
        } catch (err) {
            console.error("Could not load graph:", err);
        }
    }

    function init(data) {
        resize();
        
        nodes = data.nodes.map(n => ({
            ...n,
            x: (Math.random() - 0.5) * 500, 
            y: (Math.random() - 0.5) * 500,
            vx: 0, vy: 0,
            fx: null, fy: null 
        }));
        
        links = data.links.map(l => ({
            source: nodes.find(n => n.id === l.source),
            target: nodes.find(n => n.id === l.target)
        })).filter(l => l.source && l.target);

        requestAnimationFrame(loop);
    }

    function updatePhysics() {
        if (alpha < 0.001) return;

        // Repulsion
        for (let i = 0; i < nodes.length; i++) {
            for (let j = i + 1; j < nodes.length; j++) {
                const dx = nodes[i].x - nodes[j].x;
                const dy = nodes[i].y - nodes[j].y;
                let distSq = dx * dx + dy * dy;
                if (distSq === 0) { distSq = 1; }
                
                const force = (CONFIG.repulsion / distSq) * alpha;
                const fx = (dx / Math.sqrt(distSq)) * force;
                const fy = (dy / Math.sqrt(distSq)) * force;

                if (!nodes[i].fx) { nodes[i].vx += fx; nodes[i].vy += fy; }
                if (!nodes[j].fx) { nodes[j].vx -= fx; nodes[j].vy -= fy; }
            }
        }

        // Springs
        links.forEach(link => {
            const dx = link.target.x - link.source.x;
            const dy = link.target.y - link.source.y;
            const dist = Math.sqrt(dx * dx + dy * dy) || 1;
            
            const force = (dist - CONFIG.linkDistance) * CONFIG.stiffness * alpha;
            const fx = (dx / dist) * force;
            const fy = (dy / dist) * force;

            if (!link.source.fx) { link.source.vx += fx; link.source.vy += fy; }
            if (!link.target.fx) { link.target.vx -= fx; link.target.vy -= fy; }
        });

        // Gravity & Integration
        nodes.forEach(n => {
            if (n.fx !== null) {
                n.x = n.fx;
                n.y = n.fy;
                n.vx = 0; n.vy = 0;
                return;
            }

            n.vx -= n.x * 0.0005 * alpha;
            n.vy -= n.y * 0.0005 * alpha;

            n.x += n.vx;
            n.y += n.vy;

            n.vx *= CONFIG.friction;
            n.vy *= CONFIG.friction;
        });

        alpha *= 0.995;
    }

    function draw() {
        ctx.clearRect(0, 0, width, height);
        ctx.save();
        
        ctx.translate(width / 2 + transform.x, height / 2 + transform.y);
        ctx.scale(transform.k, transform.k);

        // Draw Links
        ctx.strokeStyle = CONFIG.colors.link;
        ctx.lineWidth = 1 / transform.k; 
        ctx.beginPath();
        links.forEach(l => {
            ctx.moveTo(l.source.x, l.source.y);
            ctx.lineTo(l.target.x, l.target.y);
        });
        ctx.stroke();

        // Draw Nodes
        nodes.forEach(n => {
            let color = n.group === 2 ? CONFIG.colors.tag : CONFIG.colors.post;
            if (n === hoveredNode || n.fx !== null) color = CONFIG.colors.highlight;

            ctx.fillStyle = color;
            ctx.beginPath();
            const r = n.val ? n.val : CONFIG.nodeRadius;
            ctx.arc(n.x, n.y, r, 0, Math.PI * 2);
            ctx.fill();

            if (transform.k > 1.2 || n === hoveredNode || n.fx !== null) {
                ctx.fillStyle = CONFIG.colors.text;
                ctx.font = '12px sans-serif';
                ctx.fillText(n.label, n.x + r + 4, n.y + 4);
            }
        });

        ctx.restore();
    }

    // --- Helpers ---
    
    // FIX: Account for canvas bounding box (padding/margins)
    function toWorld(sx, sy) {
        const rect = canvas.getBoundingClientRect();
        return {
            x: (sx - rect.left - width / 2 - transform.x) / transform.k,
            y: (sy - rect.top - height / 2 - transform.y) / transform.k
        };
    }

    // --- Interaction Handlers ---

    canvas.addEventListener('pointerdown', e => {
        const wPos = toWorld(e.clientX, e.clientY);
        
        const hitNode = nodes.find(n => {
            const r = (n.val ? n.val : CONFIG.nodeRadius) + 4; 
            return Math.hypot(n.x - wPos.x, n.y - wPos.y) < r;
        });

        if (hitNode) {
            draggedNode = hitNode;
            draggedNode.fx = draggedNode.x;
            draggedNode.fy = draggedNode.y;
            alpha = 1.0; 
            
            dragStartTime = Date.now();
            dragStartPos = { x: e.clientX, y: e.clientY };
            canvas.style.cursor = 'grabbing';
        } else {
            isPanning = true;
            startPanX = e.clientX;
            startPanY = e.clientY;
            canvas.style.cursor = 'move';
        }
    });

    window.addEventListener('pointermove', e => {
        const wPos = toWorld(e.clientX, e.clientY);

        if (draggedNode) {
            draggedNode.fx = wPos.x;
            draggedNode.fy = wPos.y;
            alpha = 0.5;
            return;
        }

        if (isPanning) {
            transform.x += e.clientX - startPanX;
            transform.y += e.clientY - startPanY;
            startPanX = e.clientX;
            startPanY = e.clientY;
            return;
        }

        const prevHover = hoveredNode;
        hoveredNode = nodes.find(n => {
            const r = (n.val ? n.val : CONFIG.nodeRadius) + 4;
            return Math.hypot(n.x - wPos.x, n.y - wPos.y) < r;
        });

        if (hoveredNode !== prevHover) {
            canvas.style.cursor = hoveredNode ? 'pointer' : 'default';
        }

        if (hoveredNode) {
            label.style.display = 'block';
            label.style.left = e.clientX + 'px';
            label.style.top = e.clientY + 'px';
            label.innerText = hoveredNode.label;
        } else {
            label.style.display = 'none';
        }
    });

    window.addEventListener('pointerup', e => {
        if (draggedNode) {
            const dist = Math.hypot(e.clientX - dragStartPos.x, e.clientY - dragStartPos.y);
            const timeDiff = Date.now() - dragStartTime;

            if (dist < 5 && timeDiff < 300 && draggedNode.url) {
                window.location.href = draggedNode.url;
            }

            draggedNode.fx = null;
            draggedNode.fy = null;
            draggedNode = null;
            alpha = 0.5;
        }

        isPanning = false;
        canvas.style.cursor = 'default';
    });

    canvas.addEventListener('wheel', e => {
        e.preventDefault();
        const zoomIntensity = 0.001;
        const delta = 1 - e.deltaY * zoomIntensity;
        const newK = Math.max(0.1, Math.min(5, transform.k * delta));
        transform.k = newK;
    }, { passive: false });

    function resize() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        width = canvas.width;
        height = canvas.height;
    }
    
    window.addEventListener('resize', resize);
    
    function loop() {
        updatePhysics();
        draw();
        requestAnimationFrame(loop);
    }
    
    loadGraph();
</script>
</body>
</html>